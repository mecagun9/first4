<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<title>삼국지3 스타일 (모바일 최적화)</title>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<style>
  :root{
    --tap:56px;         /* 모바일 터치 타깃 최적화 */
    --gap:12px;
    --font-lg:16px;
    --font-md:14px;
    --font-sm:12px;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    background:#11161c;
    color:#eaeaea;
    font-family:system-ui,apple-system,Segoe UI,Roboto,sans-serif;
    overflow-x:hidden;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }

  /* 아이폰 SE3 (375x667px, 16:9) 최적화 */
  #wrap{
    display:flex;
    flex-direction:column;
    height:100vh;
    width:100vw;
    position:fixed;
    top:0;
    left:0;
  }

  /* 상단 고정 정보바 - 아이폰 SE3 1334x750 최적화 */
  #topBar{
    position:sticky;
    top:0;
    z-index:100;
    background:#0a0f16;
    border-bottom:1px solid #2a2e38;
    padding:6px var(--gap);
    display:grid;
    grid-template-columns:1fr 1fr 1fr auto;
    gap:6px;
    align-items:center;
    min-height:48px;
  }

  /* 맵 영역 - 아이폰 SE3 1334x750 최적화 */
  #mapContainer{
    flex:0 0 65vh; /* 1334x750 해상도에서 적절한 비율 */
    position:relative;
    background:#0f1115;
    border-bottom:1px solid #2a2e38;
    overflow:auto;
    -webkit-overflow-scrolling:touch;
  }

  #mapWrapper{
    position:relative;
    min-width:100%;
    min-height:100%;
  }

  canvas{
    display:block;
    background:#0f1115;
    touch-action: none;
    position:relative;
  }

  /* 스크롤 인디케이터 */
  .scroll-indicator{
    position:absolute;
    background:rgba(139,208,255,0.3);
    border-radius:4px;
    pointer-events:none;
    transition:opacity 0.3s ease;
    opacity:0;
  }
  .scroll-indicator.show{opacity:1}
  .scroll-indicator.horizontal{
    bottom:4px;
    left:4px;
    right:4px;
    height:6px;
  }
  .scroll-indicator.vertical{
    top:4px;
    right:4px;
    bottom:4px;
    width:6px;
  }
  .scroll-thumb{
    background:#8bd0ff;
    border-radius:4px;
    position:absolute;
    transition:all 0.1s ease;
  }

  /* 하단 컨트롤 패널 - 16:9 비율 최적화 */
  #controls{
    flex:1;
    background:#141a22;
    border-top:1px solid #2a2e38;
    padding:var(--gap);
    overflow-y:auto;
    min-height:0; /* 플렉스 아이템 축소 허용 */
  }

  /* 탭 시스템 - 아이폰 SE3 1334x750 최적화 */
  .tabs{
    display:grid;
    grid-template-columns:1fr 1fr 1fr;
    margin-bottom:var(--gap);
    border-radius:8px;
    background:#0a0f16;
    overflow:hidden;
  }
  .tab{
    padding:10px 6px;
    background:#1a2332;
    border:none;
    color:#ccc;
    font-size:var(--font-md);
    cursor:pointer;
    border-right:1px solid #2a2e38;
    text-align:center;
    min-height:42px;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .tab:last-child{border-right:none}
  .tab.active{background:#2a4d6b;color:#fff}
  .tab-content{display:none}
  .tab-content.active{display:block}

  .panel{
    background:#1a2332;
    border:1px solid #2a2e38;
    border-radius:8px;
    padding:10px;
    margin-bottom:var(--gap);
  }
  
  h3{
    margin:0 0 8px 0;
    font-size:var(--font-lg);
    color:#8bd0ff;
  }

  .row{
    display:grid;
    grid-template-columns:1fr 1fr;
    gap:8px;
    margin-bottom:8px;
  }
  .row.triple{
    grid-template-columns:1fr 1fr 1fr;
  }
  .row.single{
    grid-template-columns:1fr;
  }
  
  button{
    min-height:var(--tap);
    min-width:70px;
    padding:10px 14px;
    border-radius:8px;
    border:1px solid #445169;
    background:#223048;
    color:#fff;
    font-size:var(--font-md);
    cursor:pointer;
    white-space:nowrap;
    text-align:center;
  }
  button:disabled{opacity:.5;cursor:not-allowed}
  .ghost{background:#1b2433;border-style:dashed}
  .full{grid-column:1/-1}
  .compact{min-width:auto;padding:8px 12px;font-size:var(--font-sm)}

  label, .kv{font-size:var(--font-md);line-height:1.4}
  input[type="number"]{
    width:70px;
    height:40px;
    font-size:var(--font-md);
    padding:0 8px;
    border-radius:6px;
    border:1px solid #2a2e38;
    background:#0f1115;
    color:#fff;
  }
  input[type="checkbox"]{
    width:20px;
    height:20px;
    transform:translateY(2px);
    accent-color:#5aaeff;
  }
  
  .muted{opacity:.75;font-size:var(--font-sm)}
  
  .chip{
    display:inline-block;
    min-height:32px;
    border-radius:16px;
    padding:6px 10px;
    border:1px solid #2a2e38;
    background:#10161f;
    font-size:var(--font-sm);
    margin:2px 3px 2px 0;
    white-space:nowrap;
    text-align:center;
    display:flex;
    align-items:center;
    justify-content:center;
  }

  /* 로그 영역 - 아이폰 SE3 최적화 */
  #log{
    height:120px;
    overflow:auto;
    font-size:var(--font-xs);
    line-height:1.3;
    padding:6px;
    background:#0f141c;
    border:1px solid #2a2e38;
    border-radius:4px;
  }

  /* 선택된 거점 정보 - 아이폰 SE3 최적화 */
  #selectedInfo{
    position:fixed;
    bottom:16px;
    left:50%;
    transform:translateX(-50%);
    max-width:calc(100vw - 32px);
    background:#1a2332;
    border:2px solid #ffd76b;
    border-radius:8px;
    padding:8px;
    font-size:var(--font-xs);
    z-index:200;
    display:none;
    box-shadow:0 2px 8px rgba(0,0,0,0.4);
    text-align:center;
  }

  /* 전투 오버레이 - 아이폰 SE3 최적화 */
  #battleOverlay{
    position:fixed;
    inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,.85);
    z-index:9999;
    padding:16px;
  }
  #battleBox{
    width:100%;
    max-width:360px;
    max-height:85vh;
    overflow:auto;
    background:#141a22;
    border:1px solid #2a2e38;
    border-radius:8px;
    padding:12px;
  }
  .barWrap{
    background:#0f141c;
    border:1px solid #2a2e38;
    border-radius:6px;
    height:20px;
    width:100%;
  }
  .barFillAtt{
    height:100%;
    background:#2fb36b;
    border-radius:6px;
    transition:width .35s;
  }
  .barFillDef{
    height:100%;
    background:#d94a4a;
    border-radius:6px;
    transition:width .35s;
  }
  .barLabel{
    display:flex;
    justify-content:space-between;
    font-size:var(--font-xs);
    margin-top:3px;
    margin-bottom:3px;
  }

  /* 반응형 조정 - 아이폰 SE3 (1334x750 해상도) 기준 */
  @media (max-width:375px) and (max-height:667px){
    /* 아이폰 SE3 정확한 CSS 픽셀 크기 */
    :root{--tap:44px;--font-lg:16px;--font-md:14px;--font-sm:12px;--font-xs:11px;--gap:8px}
    #mapContainer{flex:0 0 62vh}
  }
  @media (max-width:414px){
    :root{--tap:46px;--font-lg:17px;--font-md:15px;--font-sm:13px;--font-xs:12px}
    #mapContainer{flex:0 0 64vh}
  }
  @media (min-width:415px) and (max-width:768px){
    :root{--tap:48px;--font-lg:18px;--font-md:16px;--font-sm:14px}
    #mapContainer{flex:0 0 66vh}
  }
  @media (min-width:768px){
    :root{--tap:48px;--font-lg:20px;--font-md:18px}
    #wrap{flex-direction:row;height:100vh}
    #mapContainer{flex:2;border-bottom:none;border-right:1px solid #2a2e38}
    #controls{flex:1;max-width:400px;border-top:none;border-left:1px solid #2a2e38}
    #selectedInfo{position:static;transform:none;max-width:none;margin-bottom:var(--gap)}
    .row{display:flex;gap:8px}
    .row.triple{display:flex}
    .row.single{display:flex}
  }
  
  /* 아이폰 SE3 특별 최적화 */
  @media screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2){
    #mapContainer{flex:0 0 60vh} /* SE3 전용 */
    .chip{font-size:11px;padding:5px 8px}
    button{min-height:42px}
  })}
    .chip{padding:6px 10px;min-height:32px;font-size:11px}
    button{padding:10px 14px;font-size:var(--font-sm)}
    .panel{padding:10px}
    h3{font-size:14px}
    input[type="number"]{width:70px;height:40px;font-size:var(--font-sm)}
  }
  @media (min-width:481px) and (max-width:768px){
    :root{--tap:56px;--font-lg:16px;--font-md:14px;--font-sm:12px}
  }
  @media (min-width:768px){
    :root{--tap:48px;--font-lg:18px;--font-md:16px}
    #wrap{flex-direction:row}
    #mapContainer{flex:2;min-height:70vh;border-bottom:none;border-right:1px solid #2a2e38}
    #controls{flex:1;max-width:400px;border-top:none;border-left:1px solid #2a2e38}
    #selectedInfo{position:static;transform:none;max-width:none;margin-bottom:var(--gap)}
  }

  /* 진동 피드백 효과 */
  .shake{
    animation:shake 0.2s ease-in-out;
  }
  @keyframes shake{
    0%,100%{transform:translateX(0)}
    25%{transform:translateX(-2px)}
    75%{transform:translateX(2px)}
  }

  /* 터치 피드백 */
  .touch-feedback{
    position:relative;
    overflow:hidden;
  }
  .touch-feedback::after{
    content:'';
    position:absolute;
    top:50%;
    left:50%;
    width:0;
    height:0;
    border-radius:50%;
    background:rgba(255,255,255,0.3);
    transform:translate(-50%,-50%);
    transition:width 0.3s ease,height 0.3s ease;
  }
  .touch-feedback.active::after{
    width:100px;
    height:100px;
  }
</style>
</head>
<body>

<!-- 상단 정보바 -->
<div id="topBar">
  <div class="chip">턴: <b id="turn">1</b></div>
  <div class="chip">금: <b id="gold">200</b> G</div>
  <div class="chip">수입: <b id="income">0</b> G/턴</div>
  <button id="btnEndTurn" class="compact">턴 종료 ▶</button>
</div>

<div id="wrap">
  <!-- 맵 영역 -->
  <div id="mapContainer">
    <div id="mapWrapper">
      <canvas id="map" aria-label="전략 지도"></canvas>
      <!-- 스크롤 인디케이터 -->
      <div class="scroll-indicator horizontal">
        <div class="scroll-thumb" id="hThumb"></div>
      </div>
      <div class="scroll-indicator vertical">
        <div class="scroll-thumb" id="vThumb"></div>
      </div>
    </div>
  </div>

  <!-- 하단 컨트롤 -->
  <div id="controls">
    <!-- 탭 메뉴 -->
    <div class="tabs">
      <button class="tab active" data-tab="info">정보</button>
      <button class="tab" data-tab="commands">명령</button>
      <button class="tab" data-tab="log">로그</button>
    </div>

    <!-- 정보 탭 -->
    <div class="tab-content active" data-content="info">
      <div class="panel">
        <h3>거점 정보</h3>
        <div id="cityInfo" class="kv">거점을 터치하세요.</div>
      </div>
      <div class="kv muted">비용: 보병 1G / 궁수 2G / 기병 3G<br>요새화 10G (+1 방어, 최대 +5)</div>
    </div>

    <!-- 명령 탭 -->
    <div class="tab-content" data-content="commands">
      <div class="row">
        <button id="btnMove" class="touch-feedback">이동</button>
        <button id="btnRecruit" class="touch-feedback">모집</button>
      </div>
      <div class="row">
        <button id="btnFortify" class="touch-feedback">요새화</button>
        <button id="btnCancel" class="ghost touch-feedback">취소</button>
      </div>
      <div id="cmdArea"></div>
    </div>

    <!-- 로그 탭 -->
    <div class="tab-content" data-content="log">
      <div id="log" role="log" aria-live="polite"></div>
    </div>
  </div>
</div>

<!-- 선택된 거점 정보 (모바일 전용) -->
<div id="selectedInfo"></div>

<!-- 전투 오버레이 -->
<div id="battleOverlay">
  <div id="battleBox">
    <h3>전투</h3>
    <div id="battleHeader" class="kv" style="margin-bottom:8px">공격: ? → 방어: ?</div>

    <div class="row" style="gap:8px;margin-bottom:12px">
      <div class="chip">공격 영웅: <b id="attHeroName">없음</b></div>
      <div class="chip">방어 영웅: <b id="defHeroName">없음</b></div>
    </div>

    <div style="margin-bottom:8px">
      <div class="barLabel"><span>공격 전투력</span><span id="attPctTxt">0%</span></div>
      <div class="barWrap"><div id="barAtt" class="barFillAtt" style="width:0%"></div></div>
    </div>
    <div style="margin-bottom:16px">
      <div class="barLabel"><span>수비 전투력</span><span id="defPctTxt">0%</span></div>
      <div class="barWrap"><div id="barDef" class="barFillDef" style="width:0%"></div></div>
    </div>

    <div class="row" style="margin-bottom:12px">
      <button id="btnBattleRound" class="touch-feedback">라운드</button>
      <button id="btnBattleAuto" class="touch-feedback">자동</button>
    </div>
    <div class="row" style="margin-bottom:12px">
      <button id="btnBattleRetreat" class="ghost touch-feedback">퇴각</button>
      <button id="btnBattleFinish" class="touch-feedback" disabled>완료</button>
    </div>

    <div id="battleLog" style="height:200px;overflow:auto;font-size:var(--font-sm);line-height:1.4;background:#0f141c;border:1px solid #2a2e38;border-radius:8px;padding:8px"></div>
  </div>
</div>

<script>
/* ===== 모바일 유틸리티 ===== */
function addTouchFeedback(element) {
  element.addEventListener('touchstart', function() {
    this.classList.add('active');
    setTimeout(() => this.classList.remove('active'), 300);
  }, {passive: true});
}

function vibrate(pattern = [50]) {
  if ('vibrate' in navigator) {
    navigator.vibrate(pattern);
  }
}

/* ===== 탭 시스템 ===== */
function initTabs() {
  const tabs = document.querySelectorAll('.tab');
  const contents = document.querySelectorAll('.tab-content');
  
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      const target = tab.dataset.tab;
      
      tabs.forEach(t => t.classList.remove('active'));
      contents.forEach(c => c.classList.remove('active'));
      
      tab.classList.add('active');
      document.querySelector(`[data-content="${target}"]`).classList.add('active');
      
      vibrate([30]);
    });
  });
}

/* ===== 맵 스크롤링 시스템 (1334x750 최적화) ===== */
let mapScale = 1;
let mapOffsetX = 0;
let mapOffsetY = 0;
let canvasWidth = 1000;   // 아이폰 SE3 1334x750에 맞춘 크기
let canvasHeight = 700;
let viewportWidth = 375;  // CSS 픽셀 기준
let viewportHeight = 450;

function initMapDimensions() {
  const container = document.getElementById('mapContainer');
  const canvas = document.getElementById('map');
  const wrapper = document.getElementById('mapWrapper');
  
  // 뷰포트 크기 계산
  viewportWidth = container.clientWidth;
  viewportHeight = container.clientHeight;
  
  // 디바이스 픽셀 비율
  const dpr = window.devicePixelRatio || 1;
  
  // 아이폰 SE3 1334x750 해상도 기준 최적화
  const screenWidth = window.screen.width;
  const screenHeight = window.screen.height;
  
  if (screenWidth <= 375 || (screenWidth <= 750 && screenHeight <= 1334)) {
    // 아이폰 SE3 또는 유사한 해상도
    mapScale = 1;
    canvasWidth = 1000;
    canvasHeight = 700;
  } else if (screenWidth <= 414) {
    mapScale = 1.1;
    canvasWidth = 1100;
    canvasHeight = 750;
  } else if (screenWidth <= 768) {
    mapScale = 1.2;
    canvasWidth = 1200;
    canvasHeight = 800;
  } else {
    mapScale = 1.3;
    canvasWidth = 1300;
    canvasHeight = 900;
  }
  
  // 캔버스 실제 크기 설정
  canvas.width = canvasWidth * dpr;
  canvas.height = canvasHeight * dpr;
  
  // CSS 크기 설정
  canvas.style.width = canvasWidth + 'px';
  canvas.style.height = canvasHeight + 'px';
  
  // 래퍼 크기 설정 (스크롤 영역)
  wrapper.style.width = canvasWidth + 'px';
  wrapper.style.height = canvasHeight + 'px';
  
  // 컨텍스트 스케일 설정
  ctx.setTransform(dpr * mapScale, 0, 0, dpr * mapScale, 0, 0);
  
  // 초기 중앙 정렬
  setTimeout(() => centerMapOnPlayer(), 100);
}

function centerMapOnPlayer() {
  const playerCities = cities.filter(c => c.owner === PLAYER);
  if (playerCities.length > 0) {
    // 플레이어 거점들의 중심 계산
    const centerX = playerCities.reduce((sum, c) => sum + c.x, 0) / playerCities.length;
    const centerY = playerCities.reduce((sum, c) => sum + c.y, 0) / playerCities.length;
    
    // 뷰포트 중앙으로 스크롤
    const container = document.getElementById('mapContainer');
    const targetScrollLeft = Math.max(0, (centerX * mapScale) - (viewportWidth / 2));
    const targetScrollTop = Math.max(0, (centerY * mapScale) - (viewportHeight / 2));
    
    container.scrollLeft = targetScrollLeft;
    container.scrollTop = targetScrollTop;
  }
}

function updateScrollIndicators() {
  const container = document.getElementById('mapContainer');
  const hIndicator = container.querySelector('.scroll-indicator.horizontal');
  const vIndicator = container.querySelector('.scroll-indicator.vertical');
  const hThumb = document.getElementById('hThumb');
  const vThumb = document.getElementById('vThumb');
  
  const scrollLeft = container.scrollLeft;
  const scrollTop = container.scrollTop;
  const scrollWidth = container.scrollWidth;
  const scrollHeight = container.scrollHeight;
  const clientWidth = container.clientWidth;
  const clientHeight = container.clientHeight;
  
  // 가로 스크롤 인디케이터
  if (scrollWidth > clientWidth) {
    const thumbWidth = Math.max(20, (clientWidth / scrollWidth) * clientWidth);
    const thumbLeft = (scrollLeft / (scrollWidth - clientWidth)) * (clientWidth - thumbWidth);
    
    hThumb.style.width = thumbWidth + 'px';
    hThumb.style.left = thumbLeft + 'px';
    hIndicator.classList.add('show');
  } else {
    hIndicator.classList.remove('show');
  }
  
  // 세로 스크롤 인디케이터
  if (scrollHeight > clientHeight) {
    const thumbHeight = Math.max(20, (clientHeight / scrollHeight) * clientHeight);
    const thumbTop = (scrollTop / (scrollHeight - clientHeight)) * (clientHeight - thumbHeight);
    
    vThumb.style.height = thumbHeight + 'px';
    vThumb.style.top = thumbTop + 'px';
    vIndicator.classList.add('show');
  } else {
    vIndicator.classList.remove('show');
  }
  
  // 잠시 후 숨기기
  clearTimeout(window.scrollIndicatorTimeout);
  window.scrollIndicatorTimeout = setTimeout(() => {
    hIndicator.classList.remove('show');
    vIndicator.classList.remove('show');
  }, 1500);
}

/* ===== 기존 게임 로직 (변수들) ===== */
const TYPES=["INF","ARC","CAV"];
const TRAIN_COST={INF:1,ARC:2,CAV:3};
const COUNTER={ INF:{INF:1.0,ARC:1.25,CAV:0.85}, ARC:{INF:0.9,ARC:1.0,CAV:1.25}, CAV:{INF:1.25,ARC:0.85,CAV:1.0} };

const heroes={
  H01:{id:"H01",name:"관영",inTransit:false,aura:{atkPct:0.10,defPct:0.05},advantage:{INF:0.20,ARC:0.10,CAV:0.00},moraleBoost:5},
  H02:{id:"H02",name:"장광",inTransit:false,aura:{atkPct:0.05,defPct:0.10},advantage:{INF:0.00,ARC:0.20,CAV:0.10},moraleBoost:8}
};

const PLAYER="player", ENEMY="enemy", NEUT="neutral";
const cities=[
  {id:"PI",name:"북평",   x:120,y:80,  owner:NEUT,   troops:{INF:6, ARC:1,CAV:1},defense:0,income:5,  adj:["JI"],heroId:null},
  {id:"JI",name:"계(계성)",x:240,y:120, owner:PLAYER, troops:{INF:30,ARC:6,CAV:4},defense:1,income:12, adj:["PI","YE","BO"],heroId:"H01"},
  {id:"YE",name:"업",     x:360,y:140, owner:PLAYER, troops:{INF:20,ARC:6,CAV:4},defense:1,income:10, adj:["JI","BO","PU"],heroId:null},
  {id:"BO",name:"박",     x:280,y:240, owner:NEUT,   troops:{INF:12,ARC:2,CAV:1},defense:0,income:6,  adj:["JI","YE","PU","CH"],heroId:null},
  {id:"PU",name:"부",     x:440,y:220, owner:ENEMY,  troops:{INF:20,ARC:6,CAV:4},defense:1,income:9,  adj:["YE","BO","CH","LU"],heroId:"H02"},
  {id:"CH",name:"허/창",  x:360,y:320, owner:NEUT,   troops:{INF:8, ARC:1,CAV:1},defense:0,income:6,  adj:["BO","PU","LU","RU"],heroId:null},
  {id:"LU",name:"낙양",   x:500,y:300, owner:ENEMY,  troops:{INF:18,ARC:4,CAV:3},defense:1,income:9,  adj:["PU","CH","RU"],heroId:null},
  {id:"RU",name:"여남",   x:420,y:400, owner:NEUT,   troops:{INF:9, ARC:2,CAV:1},defense:0,income:6,  adj:["CH","LU","SH"],heroId:null},
  {id:"SH",name:"수춘",   x:520,y:460, owner:ENEMY,  troops:{INF:16,ARC:4,CAV:2},defense:1,income:8,  adj:["RU","GU"],heroId:null},
  {id:"GU",name:"광릉",   x:640,y:420, owner:NEUT,   troops:{INF:8, ARC:1,CAV:1},defense:0,income:6,  adj:["SH","QH"],heroId:null},
  {id:"QH",name:"건업",   x:740,y:480, owner:ENEMY,  troops:{INF:18,ARC:6,CAV:4},defense:1,income:10, adj:["GU","HU"],heroId:null},
  {id:"HU",name:"회계",   x:840,y:560, owner:NEUT,   troops:{INF:7, ARC:2,CAV:1},defense:0,income:6,  adj:["QH"],heroId:null},
];

let turn=1,gold=200;
let movements=[];
let selectedId=null,mode="idle",moveFrom=null;

/* ===== 유틸 함수들 ===== */
const logEl=document.getElementById("log");
const byId=id=>cities.find(c=>c.id===id);
const sumTroops=t=>["INF","ARC","CAV"].reduce((s,k)=>s+(t[k]||0),0);
function addTroops(a,b){["INF","ARC","CAV"].forEach(k=>a[k]=(a[k]||0)+(b[k]||0));}
function subTroops(a,b){["INF","ARC","CAV"].forEach(k=>a[k]=(a[k]||0)-(b[k]||0));}
function cloneTroops(t){return {INF:t.INF||0,ARC:t.ARC||0,CAV:t.CAV||0};}
function isAnyPositive(t){return ["INF","ARC","CAV"].some(k=> (t[k]||0)>0 );}

function log(msg){
  const d=document.createElement("div");
  d.textContent=msg;
  logEl.appendChild(d);
  logEl.scrollTop=logEl.scrollHeight;
}

function incomeOf(owner){return cities.filter(c=>c.owner===owner).reduce((s,c)=>s+c.income,0);}
function heroName(id){return id? heroes[id]?.name || "??" : "없음";}

function updateTop(){
  document.getElementById("turn").textContent=turn;
  document.getElementById("gold").textContent=gold;
  document.getElementById("income").textContent=incomeOf(PLAYER);
}

function citySummary(c){
  return `【${c.name}】 ${c.owner===PLAYER?'플레이어':c.owner===ENEMY?'적':'중립'} | 병력:${sumTroops(c.troops)} | 방어:${c.defense} | 수입:${c.income} | 영웅:${heroName(c.heroId)}`;
}

function refreshInfo(){
  const info=document.getElementById("cityInfo");
  const selectedInfo=document.getElementById("selectedInfo");
  
  if(!selectedId){
    info.textContent="거점을 터치하세요.";
    selectedInfo.style.display="none";
    return;
  }
  
  const summary = citySummary(byId(selectedId));
  info.textContent = summary;
  
  // 모바일에서는 떠있는 카드로 표시
  if(window.innerWidth < 768) {
    selectedInfo.innerHTML = summary;
    selectedInfo.style.display = "block";
    setTimeout(() => {
      selectedInfo.style.display = "none";
    }, 3000);
  }
}

/* ===== 캔버스 렌더링 (터치 범위 시각화 포함) ===== */
const canvas=document.getElementById("map");
const ctx=canvas.getContext("2d");
const NODE_R=28;
const HIT_R=NODE_R+12; // 터치 범위를 노드보다 12px 크게
const HIT_R2=HIT_R*HIT_R;

let showDebugCircles = false; // 디버그 모드

function draw(){
  const canvasRect = canvas.getBoundingClientRect();
  const clearWidth = canvas.width / (window.devicePixelRatio || 1) / mapScale;
  const clearHeight = canvas.height / (window.devicePixelRatio || 1) / mapScale;
  
  ctx.clearRect(0, 0, clearWidth, clearHeight);
  
  // 연결선
  ctx.lineWidth=2;
  cities.forEach(c=>{
    c.adj.forEach(a=>{
      const t=byId(a);
      ctx.strokeStyle="#2b384a";
      ctx.beginPath();
      ctx.moveTo(c.x,c.y);
      ctx.lineTo(t.x,t.y);
      ctx.stroke();
    });
  });
  
  // 이동 점선
  movements.forEach(m=>{
    const s=byId(m.from),t=byId(m.to);
    ctx.setLineDash([8,8]);
    ctx.strokeStyle="#b7c7ff";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(s.x,s.y);
    ctx.lineTo(t.x,t.y);
    ctx.stroke();
    ctx.setLineDash([]);
  });
  
  // 노드 및 터치 범위
  cities.forEach(c=>{
    // 디버그: 터치 범위 표시 (반투명 원)
    if(showDebugCircles){
      ctx.beginPath();
      ctx.arc(c.x,c.y,HIT_R,0,Math.PI*2);
      ctx.fillStyle="rgba(255,255,0,0.2)";
      ctx.fill();
      ctx.strokeStyle="rgba(255,255,0,0.5)";
      ctx.lineWidth=1;
      ctx.stroke();
    }
    
    // 실제 도시 노드
    ctx.beginPath();
    ctx.arc(c.x,c.y,NODE_R,0,Math.PI*2);
    ctx.fillStyle=c.owner===PLAYER?"#2fb36b":c.owner===ENEMY?"#d94a4a":"#6e7a89";
    ctx.fill();
    ctx.lineWidth=2;
    ctx.strokeStyle="#0b0e12";
    ctx.stroke();
    
    // 선택 표시
    if(c.id===selectedId){
      ctx.beginPath();
      ctx.arc(c.x,c.y,NODE_R+6,0,Math.PI*2);
      ctx.strokeStyle="#ffd76b";
      ctx.lineWidth=3;
      ctx.stroke();
    }
    
    // 텍스트 크기를 스케일에 맞게 조정
    const fontSize = Math.max(10, 14 * mapScale);
    const smallFont = Math.max(8, 12 * mapScale);
    
    if(c.defense>0){
      ctx.fillStyle="#ffde6b";
      ctx.font=`${fontSize}px sans-serif`;
      ctx.textAlign="center";
      ctx.fillText("🛡"+c.defense, c.x, c.y+NODE_R+20);
    }
    
    if(c.heroId){
      ctx.fillStyle="#ffd27f";
      ctx.font=`${smallFont}px sans-serif`;
      ctx.textAlign="center";
      ctx.fillText("★"+heroName(c.heroId), c.x, c.y+NODE_R+36);
    }
    
    ctx.fillStyle="#eaeaea";
    ctx.font=`${fontSize}px sans-serif`;
    ctx.textAlign="center";
    ctx.fillText(c.name, c.x, c.y-(NODE_R+10));
    ctx.fillText(`兵:${sumTroops(c.troops)}`, c.x, c.y+4);
  });
}

function cityAt(x,y){
  const found = cities.find(c=>{
    const dx=x-c.x;
    const dy=y-c.y;
    const distance = dx*dx+dy*dy;
    return distance <= HIT_R2;
  });
  
  // 디버그 로그
  if(showDebugCircles) {
    console.log(`터치 좌표: (${x.toFixed(1)}, ${y.toFixed(1)})`);
    if(found) {
      console.log(`발견된 도시: ${found.name} (${found.x}, ${found.y})`);
    } else {
      console.log('도시를 찾을 수 없음');
    }
  }
  
  return found?.id||null;
}

/* ===== 터치/클릭 핸들링 (개선된 좌표 변환) ===== */
function pickCityFromEvent(e){
  const container = document.getElementById('mapContainer');
  const canvas = document.getElementById('map');
  const rect = canvas.getBoundingClientRect();
  
  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  const clientY = e.touches ? e.touches[0].clientY : e.clientY;

  // 스크롤 오프셋 고려
  const scrollLeft = container.scrollLeft;
  const scrollTop = container.scrollTop;
  
  // 캔버스 좌표로 변환 (정확한 스케일 적용)
  const canvasX = (clientX - rect.left + scrollLeft) / mapScale;
  const canvasY = (clientY - rect.top + scrollTop) / mapScale;

  // 디버그 로그
  if(showDebugCircles) {
    console.log('=== 터치 디버그 ===');
    console.log(`클라이언트 좌표: (${clientX}, ${clientY})`);
    console.log(`캔버스 rect: left=${rect.left}, top=${rect.top}`);
    console.log(`스크롤: left=${scrollLeft}, top=${scrollTop}`);
    console.log(`맵 스케일: ${mapScale}`);
    console.log(`최종 캔버스 좌표: (${canvasX.toFixed(1)}, ${canvasY.toFixed(1)})`);
  }

  return cityAt(canvasX, canvasY);
}

// 터치 상태 추적
let touchState = {
  startX: 0,
  startY: 0,
  moved: false,
  startTime: 0,
  isScrolling: false
};

// 마우스 클릭 (데스크톱)
canvas.addEventListener("click",(e)=>{
  e.preventDefault();
  e.stopPropagation();
  
  const hit = pickCityFromEvent(e);
  if(hit) {
    console.log(`마우스 클릭으로 ${hit} 선택됨`);
    handleCitySelect(hit);
  } else if(showDebugCircles) {
    console.log('마우스 클릭했지만 도시를 찾을 수 없음');
  }
});

// 터치 시작
canvas.addEventListener("touchstart",(e)=>{
  const touch = e.touches[0];
  touchState.startX = touch.clientX;
  touchState.startY = touch.clientY;
  touchState.startTime = Date.now();
  touchState.moved = false;
  touchState.isScrolling = false;
},{passive: true});

// 터치 이동
canvas.addEventListener("touchmove",(e)=>{
  if (e.touches.length !== 1) return;
  
  const touch = e.touches[0];
  const moveX = Math.abs(touch.clientX - touchState.startX);
  const moveY = Math.abs(touch.clientY - touchState.startY);
  
  // 15px 이상 움직이면 스크롤로 판단
  if (moveX > 15 || moveY > 15) {
    touchState.moved = true;
    touchState.isScrolling = true;
  }
},{passive: true});

// 터치 종료
canvas.addEventListener("touchend",(e)=>{
  e.preventDefault();
  e.stopPropagation();
  
  const touchDuration = Date.now() - touchState.startTime;
  
  // 600ms 이내의 짧은 터치이고 움직임이 적으면 탭으로 처리
  if (!touchState.moved && touchDuration < 600 && !touchState.isScrolling) {
    const touch = e.changedTouches[0];
    
    // 터치 좌표를 사용하여 도시 선택
    const fakeEvent = {
      touches: [{
        clientX: touch.clientX,
        clientY: touch.clientY
      }]
    };
    
    const hit = pickCityFromEvent(fakeEvent);
    if (hit) {
      vibrate([30]);
      console.log(`터치로 ${hit} 선택됨`);
      handleCitySelect(hit);
    } else if(showDebugCircles) {
      console.log('터치했지만 도시를 찾을 수 없음');
    }
  } else if(showDebugCircles) {
    console.log(`터치 무시됨: moved=${touchState.moved}, duration=${touchDuration}ms, scrolling=${touchState.isScrolling}`);
  }
  
  // 상태 초기화
  touchState.moved = false;
  touchState.isScrolling = false;
},{passive: false});

// 디버그 모드 토글 함수 (콘솔에서 사용 가능)
function toggleDebug() {
  showDebugCircles = !showDebugCircles;
  console.log(`디버그 모드: ${showDebugCircles ? 'ON' : 'OFF'}`);
  draw();
}

// 콘솔에 도움말 출력
console.log('🎮 터치 디버깅 도구:');
console.log('- toggleDebug(): 터치 범위 시각화 토글');
console.log('- 노란색 원이 실제 터치 가능 범위입니다');

// 더블탭 방지
canvas.addEventListener("touchstart", function(e) {
  e.preventDefault();
}, {passive: false});

canvas.addEventListener("touchmove", function(e) {
  e.preventDefault();
}, {passive: false});

function handleCitySelect(hit){
  selectedId=hit;
  refreshInfo();
  setButtons();
  draw();

  if(mode==="movePick" && moveFrom){
    if(moveFrom===hit) return;
    const from=byId(moveFrom), to=byId(hit);
    if(!from.adj.includes(to.id)){
      log("인접 거점만 이동할 수 있습니다.");
      vibrate([100,50,100]); // 에러 진동
      return;
    }
    if(from.owner!==PLAYER){
      log("아군 거점에서만 이동 가능합니다.");
      vibrate([100,50,100]);
      return;
    }
    if(sumTroops(from.troops)<=0){
      log("병력이 없습니다.");
      vibrate([100,50,100]);
      return;
    }

    const heroChk = from.heroId ? 
      `<label><input type="checkbox" id="chkHero" ${heroes[from.heroId].inTransit?'disabled':''}> 영웅 동행 (${heroName(from.heroId)})</label>` : 
      `<span class="muted">영웅 없음</span>`;
    
    mode="idle";
    document.getElementById("cmdArea").innerHTML=`
      <div class="panel">
        <h3>${from.name} → ${to.name}</h3>
        <div class="row">
          <label>보병<input type="number" id="mvINF" min="0" max="${from.troops.INF}" value="${Math.min(from.troops.INF, Math.floor(from.troops.INF/2))}"></label>
          <label>궁수<input type="number" id="mvARC" min="0" max="${from.troops.ARC}" value="${Math.min(from.troops.ARC, Math.floor(from.troops.ARC/2))}"></label>
          <label>기병<input type="number" id="mvCAV" min="0" max="${from.troops.CAV}" value="${Math.min(from.troops.CAV, Math.floor(from.troops.CAV/2))}"></label>
        </div>
        <div style="margin:8px 0">${heroChk}</div>
        <button id="doMove" class="full touch-feedback">이동 실행</button>
      </div>
    `;
    
    addTouchFeedback(document.getElementById("doMove"));
    document.getElementById("doMove").onclick=()=>{
      const INF=+document.getElementById("mvINF").value||0;
      const ARC=+document.getElementById("mvARC").value||0;
      const CAV=+document.getElementById("mvCAV").value||0;
      const withHero = from.heroId && !heroes[from.heroId].inTransit && (document.getElementById("chkHero")?.checked||false);
      
      if(INF>from.troops.INF||ARC>from.troops.ARC||CAV>from.troops.CAV){
        log("병력 초과 입력입니다.");
        vibrate([100,50,100]);
        return;
      }
      if(INF+ARC+CAV<=0 && !withHero){
        log("이동 병력 또는 영웅 동행을 선택하세요.");
        vibrate([100,50,100]);
        return;
      }
      
      from.troops.INF-=INF; from.troops.ARC-=ARC; from.troops.CAV-=CAV;
      const mv={from:from.id,to:to.id,owner:from.owner,troops:{INF,ARC,CAV},heroId:withHero?from.heroId:null,turnsLeft:1};
      if(withHero){heroes[from.heroId].inTransit=true; from.heroId=null;}
      movements.push(mv);
      log(`행군: ${from.name} → ${to.name} (보${INF} 궁${ARC} 기${CAV}${withHero?`, 영웅 동행`:``})`);
      document.getElementById("cmdArea").innerHTML="";
      draw(); refreshInfo(); setButtons();
      vibrate([50,30,50]); // 성공 진동
    };
    moveFrom=null;
  }
}

/* ===== 명령 버튼들 ===== */
const btnMove=document.getElementById("btnMove");
const btnRecruit=document.getElementById("btnRecruit");
const btnFortify=document.getElementById("btnFortify");
const btnCancel=document.getElementById("btnCancel");
const btnEndTurn=document.getElementById("btnEndTurn");
const cmdArea=document.getElementById("cmdArea");

function setButtons(){
  const sel=selectedId?byId(selectedId):null;
  btnMove.disabled=!(sel && sel.owner===PLAYER && sumTroops(sel.troops)>0);
  btnRecruit.disabled=!(sel && sel.owner===PLAYER);
  btnFortify.disabled=!(sel && sel.owner===PLAYER && sel.defense<5 && gold>=10);
  btnCancel.disabled=(mode==="idle");
}

btnMove.onclick=()=>{
  if(!selectedId) return;
  mode="movePick";
  moveFrom=selectedId;
  cmdArea.innerHTML=`<div class="panel"><div class="kv">이동 대상 거점을 터치하세요. (인접만)</div></div>`;
  setButtons();
  vibrate([30]);
};

btnRecruit.onclick=()=>{
  if(!selectedId) return;
  mode="recruit";
  const c=byId(selectedId);
  cmdArea.innerHTML=`
    <div class="panel">
      <h3>모집 (보1G/궁2G/기3G)</h3>
      <div class="row">
        <label>보병<input type="number" id="rcINF" min="0" value="0"></label>
        <label>궁수<input type="number" id="rcARC" min="0" value="0"></label>
        <label>기병<input type="number" id="rcCAV" min="0" value="0"></label>
      </div>
      <button id="doRecruit" class="full touch-feedback">모집 확정</button>
    </div>
  `;
  
  addTouchFeedback(document.getElementById("doRecruit"));
  document.getElementById("doRecruit").onclick=()=>{
    const INF=+document.getElementById("rcINF").value||0;
    const ARC=+document.getElementById("rcARC").value||0;
    const CAV=+document.getElementById("rcCAV").value||0;
    const cost=INF*TRAIN_COST.INF + ARC*TRAIN_COST.ARC + CAV*TRAIN_COST.CAV;
    
    if(cost>gold){
      log(`금 부족: 필요 ${cost}G / 보유 ${gold}G`);
      vibrate([100,50,100]);
      return;
    }
    
    c.troops.INF+=INF; c.troops.ARC+=ARC; c.troops.CAV+=CAV; gold-=cost;
    log(`【${c.name}】 모집: 보${INF} 궁${ARC} 기${CAV} (−${cost}G)`);
    mode="idle";
    cmdArea.innerHTML="";
    updateTop(); refreshInfo(); draw(); setButtons();
    vibrate([50,30,50]);
  };
  setButtons();
  vibrate([30]);
};

btnFortify.onclick=()=>{
  if(!selectedId) return;
  const c=byId(selectedId);
  if(c.defense>=5 || gold<10) return;
  
  c.defense+=1; gold-=10;
  log(`【${c.name}】 요새화 +1 (방어 ${c.defense}, 금 ${gold})`);
  refreshInfo(); updateTop(); draw(); setButtons();
  vibrate([50,30,50]);
};

btnCancel.onclick=()=>{
  mode="idle";
  moveFrom=null;
  cmdArea.innerHTML="";
  setButtons();
  vibrate([30]);
};

btnEndTurn.onclick=endTurn;

/* ===== 전투 시스템 ===== */
const battleOverlay=document.getElementById("battleOverlay");
const battleHeader=document.getElementById("battleHeader");
const eAttHeroName=document.getElementById("attHeroName");
const eDefHeroName=document.getElementById("defHeroName");
const barAtt=document.getElementById("barAtt");
const barDef=document.getElementById("barDef");
const attPctTxt=document.getElementById("attPctTxt");
const defPctTxt=document.getElementById("defPctTxt");
const battleLog=document.getElementById("battleLog");
const btnBattleRound=document.getElementById("btnBattleRound");
const btnBattleAuto=document.getElementById("btnBattleAuto");
const btnBattleRetreat=document.getElementById("btnBattleRetreat");
const btnBattleFinish=document.getElementById("btnBattleFinish");

let battleState=null;

function openBattle({attFrom, attOwner, toId, att, heroId}){
  const dest=byId(toId);
  const def=cloneTroops(dest.troops);

  const attMax=Math.max(1,sumTroops(att));
  const defMax=Math.max(1,Math.floor(sumTroops(def)*(1+dest.defense*0.15)));

  battleState={
    attFrom, attOwner, toId,
    att: cloneTroops(att),
    def,
    defense: dest.defense,
    attHeroId: heroId || null,
    defHeroId: dest.heroId || null,
    finished:false, retreated:false,
    attMax, defMax
  };
  
  battleLog.innerHTML="";
  battleHeader.textContent=`공격: ${byId(attFrom).name} (${attOwner}) → 방어: ${dest.name} (${dest.owner})`;
  eAttHeroName.textContent = heroName(battleState.attHeroId);
  eDefHeroName.textContent = heroName(battleState.defHeroId);
  syncBattleBars();
  battleOverlay.style.display="flex";
  vibrate([100,50,100,50]); // 전투 시작 진동
}

function sum(t){return (t.INF|0)+(t.ARC|0)+(t.CAV|0);}

function getHeroBuff(side, enemyTroops){
  const id = side==='att'? battleState.attHeroId : battleState.defHeroId;
  if(!id) return {atkMul:1, defMul:1, morale:0};
  const h=heroes[id]; const aura=h.aura||{}; const adv=h.advantage||{};
  const total=sum(enemyTroops); let advBonus=0;
  if(total>0){ 
    ["INF","ARC","CAV"].forEach(tp=>{ 
      const portion=(enemyTroops[tp]||0)/total; 
      advBonus += (adv[tp]||0)*portion; 
    }); 
  }
  return { 
    atkMul:1+(aura.atkPct||0)+advBonus, 
    defMul:1+(aura.defPct||0), 
    morale:h.moraleBoost||0 
  };
}

function syncBattleBars(){
  const s=battleState; if(!s) return;
  const attNow=sum(s.att), defNow=sum(s.def);
  const attPct=Math.max(0,Math.min(100,Math.round((attNow/s.attMax)*100)));
  const defPct=Math.max(0,Math.min(100,Math.round(((defNow*(1+s.defense*0.15))/s.defMax)*100)));
  barAtt.style.width=attPct+"%";
  barDef.style.width=defPct+"%";
  attPctTxt.textContent=attPct+"%";
  defPctTxt.textContent=defPct+"%";
  btnBattleFinish.disabled=!s.finished;
}

function battleRoundOnce(){
  const s=battleState; if(!s || s.finished) return;
  const rand=(a,b)=> a + Math.random()*(b-a);
  const attBuff=getHeroBuff('att', s.def);
  const defBuff=getHeroBuff('def', s.att);

  let defLoss={INF:0,ARC:0,CAV:0}, attLoss={INF:0,ARC:0,CAV:0};

  // 공격 → 수비
  TYPES.forEach(aType=>{
    const base=s.att[aType]; if(base<=0) return;
    TYPES.forEach(dType=>{
      const mult=COUNTER[aType][dType];
      const power=Math.floor( base * rand(0.18,0.26) * mult * attBuff.atkMul * (1 + attBuff.morale/100) );
      defLoss[dType]+=power;
    });
  });

  // 수비 → 공격
  TYPES.forEach(dType=>{
    const base=s.def[dType]; if(base<=0) return;
    TYPES.forEach(aType=>{
      const mult=COUNTER[dType][aType];
      const power=Math.floor( base * rand(0.12,0.20) * mult * defBuff.defMul * (1 + defBuff.morale/100) * (1 + s.defense*0.08) );
      attLoss[aType]+=power;
    });
  });

  // 수비 피해 감소
  TYPES.forEach(t=>{ 
    defLoss[t]=Math.max(0, Math.floor(defLoss[t] * (1 - Math.min(0.45, s.defense*0.07)))); 
  });

  // 적용
  TYPES.forEach(t=>{ 
    s.def[t]=Math.max(0,s.def[t]-defLoss[t]); 
    s.att[t]=Math.max(0,s.att[t]-attLoss[t]); 
  });

  const line=`라운드 ▶ 수비피해: -${defLoss.INF+defLoss.ARC+defLoss.CAV} / 공격피해: -${attLoss.INF+attLoss.ARC+attLoss.CAV}`;
  const d=document.createElement("div"); 
  d.textContent=line; 
  battleLog.appendChild(d); 
  battleLog.scrollTop=battleLog.scrollHeight;

  if(!isAnyPositive(s.att) || !isAnyPositive(s.def)){ 
    s.finished=true; 
    vibrate([200]); // 전투 종료 진동
  } else {
    vibrate([30]); // 라운드 진동
  }
  syncBattleBars();
}

// 전투 버튼들에 터치 피드백 추가
addTouchFeedback(btnBattleRound);
addTouchFeedback(btnBattleAuto);
addTouchFeedback(btnBattleRetreat);
addTouchFeedback(btnBattleFinish);

btnBattleRound.onclick=battleRoundOnce;

btnBattleAuto.onclick=()=>{
  let g=0;
  const autoInterval = setInterval(() => {
    if(!battleState || battleState.finished || g>=64) {
      clearInterval(autoInterval);
      return;
    }
    battleRoundOnce();
    g++;
  }, 500); // 0.5초 간격으로 자동 전투
};

btnBattleRetreat.onclick=()=>{
  if(!battleState||battleState.finished)return;
  battleState.retreated=true;
  battleState.finished=true;
  const d=document.createElement("div");
  d.innerHTML="<b>퇴각!</b>";
  battleLog.appendChild(d);
  battleLog.scrollTop=battleLog.scrollHeight;
  syncBattleBars();
  vibrate([100,50,100]);
};

btnBattleFinish.onclick=()=>{
  const s=battleState; if(!s||!s.finished)return; 
  const dest=byId(s.toId);
  
  if(s.retreated){
    if(isAnyPositive(s.att)){ 
      addTroops(byId(s.attFrom).troops, s.att); 
      log(`퇴각: ${byId(s.attFrom).name} 귀환`); 
    }
    if(s.attHeroId){ 
      byId(s.attFrom).heroId=s.attHeroId; 
      heroes[s.attHeroId].inTransit=false; 
      log(`영웅 ${heroName(s.attHeroId)} 퇴각 복귀`); 
    }
  }else{
    const attSum=sum(s.att), defSum=sum(s.def);
    if(defSum<=0 && attSum>0){
      if(s.defHeroId){ 
        log(`수비 영웅 ${heroName(s.defHeroId)} 도주`); 
      }
      dest.owner=s.attOwner; 
      dest.troops=cloneTroops(s.att); 
      dest.defense=Math.max(0,dest.defense-1);
      dest.heroId=s.attHeroId||null; 
      if(s.attHeroId){ 
        heroes[s.attHeroId].inTransit=false; 
      }
      log(`함락! ${dest.name} 점령${s.attHeroId?` (영웅 ${heroName(s.attHeroId)} 부임)`:""}`);
      vibrate([200,100,200]); // 승리 진동
    }else{
      dest.troops=cloneTroops(s.def);
      if(attSum>0){ 
        addTroops(byId(s.attFrom).troops, s.att); 
        log(`공격 실패, ${byId(s.attFrom).name} 귀환`); 
      }
      if(s.attHeroId){ 
        byId(s.attFrom).heroId=s.attHeroId; 
        heroes[s.attHeroId].inTransit=false; 
        log(`영웅 ${heroName(s.attHeroId)} 공격 실패 복귀`); 
      }
      log(`방어 성공: ${dest.name}`);
    }
  }
  
  battleOverlay.style.display="none"; 
  battleState=null; 
  draw(); 
  refreshInfo(); 
  updateTop();
};

/* ===== 이동/전투 처리 ===== */
function resolveMovementsOrOpenBattles(){
  const idx=movements.findIndex(m=>m.turnsLeft<=0);
  if(idx===-1) return false;
  
  const m=movements[idx], dest=byId(m.to);
  if(dest.owner===m.owner){
    addTroops(dest.troops, m.troops);
    if(m.heroId){ 
      dest.heroId=m.heroId; 
      heroes[m.heroId].inTransit=false; 
      log(`영웅 ${heroName(m.heroId)} ${dest.name} 부임`); 
    }
    log(`합류: ${dest.name}`);
    movements.splice(idx,1); 
    return true;
  }else{
    openBattle({
      attFrom:m.from, 
      attOwner:m.owner, 
      toId:m.to, 
      att:m.troops, 
      heroId:m.heroId||null
    });
    movements.splice(idx,1); 
    return true;
  }
}

function resolveMovementsStepwise(){
  for(let i=0;i<movements.length;i++){
    movements[i].turnsLeft--;
  }
  while(true){
    const progressed=resolveMovementsOrOpenBattles();
    if(!progressed) break;
    if(battleState) break;
  }
}

/* ===== AI ===== */
function aiPhase(){
  const aiCities=cities.filter(c=>c.owner===ENEMY && sumTroops(c.troops)>=12);
  for(const from of aiCities){
    const targets=from.adj.map(id=>byId(id)).filter(t=>t.owner!==ENEMY);
    if(targets.length===0) continue;
    
    targets.sort((a,b)=>(sumTroops(a.troops)+a.defense*2)-(sumTroops(b.troops)+b.defense*2));
    const to=targets[0];
    const send=cloneTroops({
      INF:Math.floor(from.troops.INF/2),
      ARC:Math.floor(from.troops.ARC/2),
      CAV:Math.floor(from.troops.CAV/2)
    });
    
    if(sumTroops(send)>0){
      subTroops(from.troops, send);
      let heroId=null;
      if(from.heroId && !heroes[from.heroId].inTransit && Math.random()<0.5){ 
        heroId=from.heroId; 
        from.heroId=null; 
        heroes[heroId].inTransit=true; 
      }
      movements.push({
        from:from.id,
        to:to.id,
        owner:ENEMY,
        troops:send,
        heroId,
        turnsLeft:1
      });
      log(`(AI) 행군: ${from.name} → ${to.name}${heroId?` (영웅 동행)`:``}`);
    }
  }
}

/* ===== 턴 종료 ===== */
function endTurn(){
  gold+=incomeOf(PLAYER);
  resolveMovementsStepwise(); 
  if(battleState){ 
    updateTop(); 
    draw(); 
    refreshInfo(); 
    return; 
  }
  
  aiPhase();
  resolveMovementsStepwise(); 
  if(battleState){ 
    updateTop(); 
    draw(); 
    refreshInfo(); 
    return; 
  }
  
  turn++;
  updateTop(); 
  draw(); 
  refreshInfo();
  vibrate([50]); // 턴 종료 피드백
}

/* ===== 초기화 (스크롤링 포함) ===== */
function bootstrap(){
  // 맵 크기 초기화
  initMapDimensions();
  
  updateTop(); 
  refreshInfo(); 
  draw(); 
  log("게임 시작. 플레이어의 턴입니다.");
  
  // 터치 피드백 추가
  document.querySelectorAll('.touch-feedback').forEach(addTouchFeedback);
  
  // 탭 시스템 초기화
  initTabs();
  
  // 스크롤 이벤트 리스너
  const container = document.getElementById('mapContainer');
  container.addEventListener('scroll', updateScrollIndicators, {passive: true});
  
  // 초기 스크롤 인디케이터 업데이트
  setTimeout(updateScrollIndicators, 100);
}

function fixHiDPI(){
  initMapDimensions();
  draw();
}

// 리사이즈 이벤트 핸들러
function handleResize() {
  clearTimeout(window.resizeTimeout);
  window.resizeTimeout = setTimeout(() => {
    initMapDimensions();
    draw();
    updateScrollIndicators();
  }, 100);
}

window.addEventListener('resize', handleResize);
window.addEventListener('orientationchange', () => {
  setTimeout(() => {
    initMapDimensions();
    draw();
    updateScrollIndicators();
    // 방향 전환 후 다시 플레이어 중심으로
    setTimeout(centerMapOnPlayer, 200);
  }, 100);
});

// 게임 시작
bootstrap();

</script>
</body>
</html>
